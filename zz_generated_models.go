//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package main

import (
	"encoding/json"
	"encoding/xml"
	"reflect"
	"time"

	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
)

// AuthorizationRule - Authorization rule of an entity
type AuthorizationRule struct {
	// The claim type.
	ClaimType *string `json:"claimType,omitempty"`

	// The claim value.
	ClaimValue *string `json:"claimValue,omitempty"`

	// The date and time when the authorization rule was created.
	CreatedTime *time.Time `json:"createdTime,omitempty"`

	// The authorization rule key name
	KeyName *string `json:"keyName,omitempty"`

	// The date and time when the authorization rule was modified.
	ModifiedTime *time.Time `json:"modifiedTime,omitempty"`

	// The primary key of the authorization rule
	PrimaryKey *string `json:"primaryKey,omitempty"`

	// Access rights of the entity. Values are 'Send', 'Listen', or 'Manage'
	Rights []*AccessRights `json:"rights,omitempty"`

	// The primary key of the authorization rule
	SecondaryKey *string `json:"secondaryKey,omitempty"`

	// The authorization type.
	Type *string `json:"type,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AuthorizationRule.
func (a AuthorizationRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "claimType", a.ClaimType)
	populate(objectMap, "claimValue", a.ClaimValue)
	populate(objectMap, "createdTime", (*timeRFC3339)(a.CreatedTime))
	populate(objectMap, "keyName", a.KeyName)
	populate(objectMap, "modifiedTime", (*timeRFC3339)(a.ModifiedTime))
	populate(objectMap, "primaryKey", a.PrimaryKey)
	populate(objectMap, "rights", a.Rights)
	populate(objectMap, "secondaryKey", a.SecondaryKey)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AuthorizationRule.
func (a *AuthorizationRule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "claimType":
				err = unpopulate(val, &a.ClaimType)
				delete(rawMsg, key)
		case "claimValue":
				err = unpopulate(val, &a.ClaimValue)
				delete(rawMsg, key)
		case "createdTime":
				var aux timeRFC3339
				err = unpopulate(val, &aux)
				a.CreatedTime = (*time.Time)(&aux)
				delete(rawMsg, key)
		case "keyName":
				err = unpopulate(val, &a.KeyName)
				delete(rawMsg, key)
		case "modifiedTime":
				var aux timeRFC3339
				err = unpopulate(val, &aux)
				a.ModifiedTime = (*time.Time)(&aux)
				delete(rawMsg, key)
		case "primaryKey":
				err = unpopulate(val, &a.PrimaryKey)
				delete(rawMsg, key)
		case "rights":
				err = unpopulate(val, &a.Rights)
				delete(rawMsg, key)
		case "secondaryKey":
				err = unpopulate(val, &a.SecondaryKey)
				delete(rawMsg, key)
		case "type":
				err = unpopulate(val, &a.Type)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type CorrelationFilter struct {
	RuleFilter
	ContentType *string `json:"contentType,omitempty"`
	CorrelationID *string `json:"correlationId,omitempty"`
	Label *string `json:"label,omitempty"`
	MessageID *string `json:"messageId,omitempty"`
	Properties []*KeyValue `json:"properties,omitempty"`
	ReplyTo *string `json:"replyTo,omitempty"`
	ReplyToSessionID *string `json:"replyToSessionId,omitempty"`
	SessionID *string `json:"sessionId,omitempty"`
	To *string `json:"to,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CorrelationFilter.
func (c CorrelationFilter) MarshalJSON() ([]byte, error) {
	objectMap := c.RuleFilter.marshalInternal("CorrelationFilter")
	populate(objectMap, "contentType", c.ContentType)
	populate(objectMap, "correlationId", c.CorrelationID)
	populate(objectMap, "label", c.Label)
	populate(objectMap, "messageId", c.MessageID)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "replyTo", c.ReplyTo)
	populate(objectMap, "replyToSessionId", c.ReplyToSessionID)
	populate(objectMap, "sessionId", c.SessionID)
	populate(objectMap, "to", c.To)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CorrelationFilter.
func (c *CorrelationFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "contentType":
				err = unpopulate(val, &c.ContentType)
				delete(rawMsg, key)
		case "correlationId":
				err = unpopulate(val, &c.CorrelationID)
				delete(rawMsg, key)
		case "label":
				err = unpopulate(val, &c.Label)
				delete(rawMsg, key)
		case "messageId":
				err = unpopulate(val, &c.MessageID)
				delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, &c.Properties)
				delete(rawMsg, key)
		case "replyTo":
				err = unpopulate(val, &c.ReplyTo)
				delete(rawMsg, key)
		case "replyToSessionId":
				err = unpopulate(val, &c.ReplyToSessionID)
				delete(rawMsg, key)
		case "sessionId":
				err = unpopulate(val, &c.SessionID)
				delete(rawMsg, key)
		case "to":
				err = unpopulate(val, &c.To)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return c.RuleFilter.unmarshalInternal(rawMsg)
}

// CreateQueueBody - The request body for creating a queue.
type CreateQueueBody struct {
	// QueueDescription for the new queue.
	Content *CreateQueueBodyContent `json:"content,omitempty"`
}

// CreateQueueBodyContent - QueueDescription for the new queue.
type CreateQueueBodyContent struct {
	// Properties of the new queue.
	QueueDescription *QueueDescription `json:"queueDescription,omitempty"`

	// MIME type of content.
	Type *string `json:"type,omitempty"`
}

// CreateRuleBody - The request body for creating a rule.
type CreateRuleBody struct {
	// RuleDescription for the new Rule.
	Content *CreateRuleBodyContent `json:"content,omitempty"`
}

// CreateRuleBodyContent - RuleDescription for the new Rule.
type CreateRuleBodyContent struct {
	// Rule information to create.
	RuleDescription *RuleDescription `json:"ruleDescription,omitempty"`

	// MIME type of content.
	Type *string `json:"type,omitempty"`
}

// CreateSubscriptionBody - The request body for creating a subscription.
type CreateSubscriptionBody struct {
	// SubscriptionDescription for the new subscription.
	Content *CreateSubscriptionBodyContent `json:"content,omitempty"`
}

// CreateSubscriptionBodyContent - SubscriptionDescription for the new subscription.
type CreateSubscriptionBodyContent struct {
	// Subscription information to create.
	SubscriptionDescription *SubscriptionDescription `json:"subscriptionDescription,omitempty"`

	// MIME type of content.
	Type *string `json:"type,omitempty"`
}

// CreateTopicBody - The request body for creating a topic.
type CreateTopicBody struct {
	// TopicDescription for the new topic.
	Content *CreateTopicBodyContent `json:"content,omitempty"`
}

// CreateTopicBodyContent - TopicDescription for the new topic.
type CreateTopicBodyContent struct {
	// Topic information to create.
	TopicDescription *TopicDescription `json:"topicDescription,omitempty"`

	// MIME type of content.
	Type *string `json:"type,omitempty"`
}

type EmptyRuleAction struct {
	RuleAction
}

// MarshalJSON implements the json.Marshaller interface for type EmptyRuleAction.
func (e EmptyRuleAction) MarshalJSON() ([]byte, error) {
	objectMap := e.RuleAction.marshalInternal("EmptyRuleAction")
	return json.Marshal(objectMap)
}

// EntityDeleteOptions contains the optional parameters for the Entity.Delete method.
type EntityDeleteOptions struct {
}

// EntityGetOptions contains the optional parameters for the Entity.Get method.
type EntityGetOptions struct {
	// A query parameter that sets enrich to true or false.
	Enrich *bool
}

// EntityPutOptions contains the optional parameters for the Entity.Put method.
type EntityPutOptions struct {
	// Match condition for an entity to be updated. If specified and a matching entity is not found, an error will be raised. To force an unconditional update,
// set to the wildcard character (*). If not specified, an insert will be performed when no existing entity is found to update and a replace will be performed
// if an existing entity is found.
	IfMatch *string
}

type FalseFilter struct {
	SQLFilter
}

// MarshalJSON implements the json.Marshaller interface for type FalseFilter.
func (f FalseFilter) MarshalJSON() ([]byte, error) {
	objectMap := f.SQLFilter.marshalInternal("FalseFilter")
	return json.Marshal(objectMap)
}

// KeyValue - Key Values of custom properties
type KeyValue struct {
	Key *string `json:"key,omitempty"`
	Value *string `json:"value,omitempty"`
}

// MessageCountDetails - Details about the message counts in entity.
type MessageCountDetails struct {
	// Number of active messages in the queue, topic, or subscription.
	ActiveMessageCount *int32 `json:"activeMessageCount,omitempty"`

	// Number of messages that are dead lettered.
	DeadLetterMessageCount *int32 `json:"deadLetterMessageCount,omitempty"`

	// Number of scheduled messages.
	ScheduledMessageCount *int32 `json:"scheduledMessageCount,omitempty"`

	// Number of messages transferred into dead letters.
	TransferDeadLetterMessageCount *int32 `json:"transferDeadLetterMessageCount,omitempty"`

	// Number of messages transferred to another queue, topic, or subscription.
	TransferMessageCount *int32 `json:"transferMessageCount,omitempty"`
}

// NamespaceGetOptions contains the optional parameters for the Namespace.Get method.
type NamespaceGetOptions struct {
}

// NamespaceProperties - The metadata related to a Service Bus namespace.
type NamespaceProperties struct {
	// Alias for the geo-disaster recovery Service Bus namespace.
	Alias *string `xml:"Alias"`

	// The exact time the namespace was created.
	CreatedTime *time.Time `xml:"CreatedTime"`

	// The SKU for the messaging entity.
	MessagingSKU *MessagingSKU `xml:"MessagingSKU"`

	// The number of messaging units allocated to the namespace.
	MessagingUnits *int32 `xml:"MessagingUnits"`

	// The exact time the namespace was last modified.
	ModifiedTime *time.Time `xml:"ModifiedTime"`

	// Name of the namespace
	Name *string `xml:"Name"`

	// The type of entities the namespace can contain.
	NamespaceType *NamespaceType `xml:"NamespaceType"`
}

// MarshalXML implements the xml.Marshaller interface for type NamespaceProperties.
func (n NamespaceProperties) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	type alias NamespaceProperties
	aux := &struct {
		*alias
		CreatedTime *timeRFC3339 `xml:"CreatedTime"`
		ModifiedTime *timeRFC3339 `xml:"ModifiedTime"`
	}{
		alias: (*alias)(&n),
		CreatedTime: (*timeRFC3339)(n.CreatedTime),
		ModifiedTime: (*timeRFC3339)(n.ModifiedTime),
	}
	return e.EncodeElement(aux, start)
}

// UnmarshalXML implements the xml.Unmarshaller interface for type NamespaceProperties.
func (n *NamespaceProperties) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type alias NamespaceProperties
	aux := &struct {
		*alias
		CreatedTime *timeRFC3339 `xml:"CreatedTime"`
		ModifiedTime *timeRFC3339 `xml:"ModifiedTime"`
	}{
		alias: (*alias)(n),
	}
	if err := d.DecodeElement(aux, &start); err != nil {
		return err
	}
	n.CreatedTime = (*time.Time)(aux.CreatedTime)
	n.ModifiedTime = (*time.Time)(aux.ModifiedTime)
	return nil
}

// NamespacePropertiesEntry - Represents an entry in the feed when querying namespace info
type NamespacePropertiesEntry struct {
	// The author that created this resource
	Author *ResponseAuthor `xml:"author"`

	// Information about the namespace.
	Content *NamespacePropertiesEntryContent `xml:"content"`

	// The URL of the GET request
	ID *string `xml:"id"`

	// The URL for the HTTP request
	Link *ResponseLink `xml:"link"`

	// The name of the namespace.
	Title map[string]interface{} `xml:"title"`

	// The timestamp for when this namespace was last updated
	Updated *time.Time `xml:"updated"`
}

// MarshalXML implements the xml.Marshaller interface for type NamespacePropertiesEntry.
func (n NamespacePropertiesEntry) MarshalXML(e *xml.Encoder, start xml.StartElement) error {
	type alias NamespacePropertiesEntry
	aux := &struct {
		*alias
		Updated *timeRFC3339 `xml:"updated"`
	}{
		alias: (*alias)(&n),
		Updated: (*timeRFC3339)(n.Updated),
	}
	return e.EncodeElement(aux, start)
}

// UnmarshalXML implements the xml.Unmarshaller interface for type NamespacePropertiesEntry.
func (n *NamespacePropertiesEntry) UnmarshalXML(d *xml.Decoder, start xml.StartElement) error {
	type alias NamespacePropertiesEntry
	aux := &struct {
		*alias
		Updated *timeRFC3339 `xml:"updated"`
	}{
		alias: (*alias)(n),
	}
	if err := d.DecodeElement(aux, &start); err != nil {
		return err
	}
	n.Updated = (*time.Time)(aux.Updated)
	return nil
}

// NamespacePropertiesEntryContent - Information about the namespace.
type NamespacePropertiesEntryContent struct {
	// The metadata related to a Service Bus namespace.
	NamespaceProperties *NamespaceProperties `xml:"NamespaceInfo"`

	// Type of content in namespace info response
	Type *string `xml:"type,attr"`
}

// QueueDescription - Description of a Service Bus queue resource.
type QueueDescription struct {
	// Last time a message was sent, or the last time there was a receive request to this queue.
	AccessedAt *time.Time `json:"accessedAt,omitempty"`

	// Authorization rules for resource.
	AuthorizationRules []*AuthorizationRule `json:"authorizationRules,omitempty"`

	// ISO 8601 timeSpan idle interval after which the queue is automatically deleted. The minimum duration is 5 minutes.
	AutoDeleteOnIdle *string `json:"autoDeleteOnIdle,omitempty"`

	// The exact time the queue was created.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// A value that indicates whether this queue has dead letter support when a message expires.
	DeadLetteringOnMessageExpiration *bool `json:"deadLetteringOnMessageExpiration,omitempty"`

	// ISO 8601 default message timespan to live value. This is the duration after which the message expires, starting from when the message is sent to Service
// Bus. This is the default value used when
// TimeToLive is not set on a message itself.
	DefaultMessageTimeToLive *string `json:"defaultMessageTimeToLive,omitempty"`

	// ISO 8601 timeSpan structure that defines the duration of the duplicate detection history. The default value is 10 minutes.
	DuplicateDetectionHistoryTimeWindow *string `json:"duplicateDetectionHistoryTimeWindow,omitempty"`

	// Value that indicates whether server-side batched operations are enabled.
	EnableBatchedOperations *bool `json:"enableBatchedOperations,omitempty"`

	// A value that indicates whether Express Entities are enabled. An express queue holds a message in memory temporarily before writing it to persistent storage.
	EnableExpress *bool `json:"enableExpress,omitempty"`

	// A value that indicates whether the queue is to be partitioned across multiple message brokers.
	EnablePartitioning *bool `json:"enablePartitioning,omitempty"`

	// Availability status of the entity
	EntityAvailabilityStatus *EntityAvailabilityStatus `json:"entityAvailabilityStatus,omitempty"`

	// The name of the recipient entity to which all the dead-lettered messages of this subscription are forwarded to.
	ForwardDeadLetteredMessagesTo *string `json:"forwardDeadLetteredMessagesTo,omitempty"`

	// The name of the recipient entity to which all the messages sent to the queue are forwarded to.
	ForwardTo *string `json:"forwardTo,omitempty"`

	// A value indicating if the resource can be accessed without authorization.
	IsAnonymousAccessible *bool `json:"isAnonymousAccessible,omitempty"`

	// ISO 8601 timespan duration of a peek-lock; that is, the amount of time that the message is locked for other receivers. The maximum value for LockDuration
// is 5 minutes; the default value is 1 minute.
	LockDuration *string `json:"lockDuration,omitempty"`

	// The maximum delivery count. A message is automatically deadlettered after this number of deliveries. Default value is 10.
	MaxDeliveryCount *int32 `json:"maxDeliveryCount,omitempty"`

	// The maximum size of the queue in megabytes, which is the size of memory allocated for the queue.
	MaxSizeInMegabytes *int64 `json:"maxSizeInMegabytes,omitempty"`

	// The number of messages in the queue.
	MessageCount *int32 `json:"messageCount,omitempty"`

	// Details about the message counts in entity.
	MessageCountDetails *MessageCountDetails `json:"messageCountDetails,omitempty"`

	// A value indicating if this queue requires duplicate detection.
	RequiresDuplicateDetection *bool `json:"requiresDuplicateDetection,omitempty"`

	// A value that indicates whether the queue supports the concept of sessions.
	RequiresSession *bool `json:"requiresSession,omitempty"`

	// The size of the queue, in bytes.
	SizeInBytes *int32 `json:"sizeInBytes,omitempty"`

	// Status of a Service Bus resource
	Status *EntityStatus `json:"status,omitempty"`

	// A value that indicates whether the queue supports ordering.
	SupportOrdering *bool `json:"supportOrdering,omitempty"`

	// The exact time the entity description was last updated.
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Custom metdata that user can associate with the description. Max length is 1024 chars.
	UserMetadata *string `json:"userMetadata,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type QueueDescription.
func (q QueueDescription) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accessedAt", (*timeRFC3339)(q.AccessedAt))
	populate(objectMap, "authorizationRules", q.AuthorizationRules)
	populate(objectMap, "autoDeleteOnIdle", q.AutoDeleteOnIdle)
	populate(objectMap, "createdAt", (*timeRFC3339)(q.CreatedAt))
	populate(objectMap, "deadLetteringOnMessageExpiration", q.DeadLetteringOnMessageExpiration)
	populate(objectMap, "defaultMessageTimeToLive", q.DefaultMessageTimeToLive)
	populate(objectMap, "duplicateDetectionHistoryTimeWindow", q.DuplicateDetectionHistoryTimeWindow)
	populate(objectMap, "enableBatchedOperations", q.EnableBatchedOperations)
	populate(objectMap, "enableExpress", q.EnableExpress)
	populate(objectMap, "enablePartitioning", q.EnablePartitioning)
	populate(objectMap, "entityAvailabilityStatus", q.EntityAvailabilityStatus)
	populate(objectMap, "forwardDeadLetteredMessagesTo", q.ForwardDeadLetteredMessagesTo)
	populate(objectMap, "forwardTo", q.ForwardTo)
	populate(objectMap, "isAnonymousAccessible", q.IsAnonymousAccessible)
	populate(objectMap, "lockDuration", q.LockDuration)
	populate(objectMap, "maxDeliveryCount", q.MaxDeliveryCount)
	populate(objectMap, "maxSizeInMegabytes", q.MaxSizeInMegabytes)
	populate(objectMap, "messageCount", q.MessageCount)
	populate(objectMap, "messageCountDetails", q.MessageCountDetails)
	populate(objectMap, "requiresDuplicateDetection", q.RequiresDuplicateDetection)
	populate(objectMap, "requiresSession", q.RequiresSession)
	populate(objectMap, "sizeInBytes", q.SizeInBytes)
	populate(objectMap, "status", q.Status)
	populate(objectMap, "supportOrdering", q.SupportOrdering)
	populate(objectMap, "updatedAt", (*timeRFC3339)(q.UpdatedAt))
	populate(objectMap, "userMetadata", q.UserMetadata)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type QueueDescription.
func (q *QueueDescription) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessedAt":
				var aux timeRFC3339
				err = unpopulate(val, &aux)
				q.AccessedAt = (*time.Time)(&aux)
				delete(rawMsg, key)
		case "authorizationRules":
				err = unpopulate(val, &q.AuthorizationRules)
				delete(rawMsg, key)
		case "autoDeleteOnIdle":
				err = unpopulate(val, &q.AutoDeleteOnIdle)
				delete(rawMsg, key)
		case "createdAt":
				var aux timeRFC3339
				err = unpopulate(val, &aux)
				q.CreatedAt = (*time.Time)(&aux)
				delete(rawMsg, key)
		case "deadLetteringOnMessageExpiration":
				err = unpopulate(val, &q.DeadLetteringOnMessageExpiration)
				delete(rawMsg, key)
		case "defaultMessageTimeToLive":
				err = unpopulate(val, &q.DefaultMessageTimeToLive)
				delete(rawMsg, key)
		case "duplicateDetectionHistoryTimeWindow":
				err = unpopulate(val, &q.DuplicateDetectionHistoryTimeWindow)
				delete(rawMsg, key)
		case "enableBatchedOperations":
				err = unpopulate(val, &q.EnableBatchedOperations)
				delete(rawMsg, key)
		case "enableExpress":
				err = unpopulate(val, &q.EnableExpress)
				delete(rawMsg, key)
		case "enablePartitioning":
				err = unpopulate(val, &q.EnablePartitioning)
				delete(rawMsg, key)
		case "entityAvailabilityStatus":
				err = unpopulate(val, &q.EntityAvailabilityStatus)
				delete(rawMsg, key)
		case "forwardDeadLetteredMessagesTo":
				err = unpopulate(val, &q.ForwardDeadLetteredMessagesTo)
				delete(rawMsg, key)
		case "forwardTo":
				err = unpopulate(val, &q.ForwardTo)
				delete(rawMsg, key)
		case "isAnonymousAccessible":
				err = unpopulate(val, &q.IsAnonymousAccessible)
				delete(rawMsg, key)
		case "lockDuration":
				err = unpopulate(val, &q.LockDuration)
				delete(rawMsg, key)
		case "maxDeliveryCount":
				err = unpopulate(val, &q.MaxDeliveryCount)
				delete(rawMsg, key)
		case "maxSizeInMegabytes":
				err = unpopulate(val, &q.MaxSizeInMegabytes)
				delete(rawMsg, key)
		case "messageCount":
				err = unpopulate(val, &q.MessageCount)
				delete(rawMsg, key)
		case "messageCountDetails":
				err = unpopulate(val, &q.MessageCountDetails)
				delete(rawMsg, key)
		case "requiresDuplicateDetection":
				err = unpopulate(val, &q.RequiresDuplicateDetection)
				delete(rawMsg, key)
		case "requiresSession":
				err = unpopulate(val, &q.RequiresSession)
				delete(rawMsg, key)
		case "sizeInBytes":
				err = unpopulate(val, &q.SizeInBytes)
				delete(rawMsg, key)
		case "status":
				err = unpopulate(val, &q.Status)
				delete(rawMsg, key)
		case "supportOrdering":
				err = unpopulate(val, &q.SupportOrdering)
				delete(rawMsg, key)
		case "updatedAt":
				var aux timeRFC3339
				err = unpopulate(val, &aux)
				q.UpdatedAt = (*time.Time)(&aux)
				delete(rawMsg, key)
		case "userMetadata":
				err = unpopulate(val, &q.UserMetadata)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// QueueDescriptionEntry - Represents an entry in the feed when querying queues
type QueueDescriptionEntry struct {
	// The author that created this resource
	Author *ResponseAuthor `json:"author,omitempty"`

	// Base URL for the query.
	Base *string `json:"base,omitempty"`

	// The QueueDescription
	Content *QueueDescriptionEntryContent `json:"content,omitempty"`

	// The URL of the GET request
	ID *string `json:"id,omitempty"`

	// The URL for the HTTP request
	Link *ResponseLink `json:"link,omitempty"`

	// The timestamp for when this queue was published
	Published *time.Time `json:"published,omitempty"`

	// The name of the queue
	Title map[string]interface{} `json:"title,omitempty"`

	// The timestamp for when this queue was last updated
	Updated *time.Time `json:"updated,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type QueueDescriptionEntry.
func (q QueueDescriptionEntry) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "author", q.Author)
	populate(objectMap, "base", q.Base)
	populate(objectMap, "content", q.Content)
	populate(objectMap, "id", q.ID)
	populate(objectMap, "link", q.Link)
	populate(objectMap, "published", (*timeRFC3339)(q.Published))
	populate(objectMap, "title", q.Title)
	populate(objectMap, "updated", (*timeRFC3339)(q.Updated))
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type QueueDescriptionEntry.
func (q *QueueDescriptionEntry) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "author":
				err = unpopulate(val, &q.Author)
				delete(rawMsg, key)
		case "base":
				err = unpopulate(val, &q.Base)
				delete(rawMsg, key)
		case "content":
				err = unpopulate(val, &q.Content)
				delete(rawMsg, key)
		case "id":
				err = unpopulate(val, &q.ID)
				delete(rawMsg, key)
		case "link":
				err = unpopulate(val, &q.Link)
				delete(rawMsg, key)
		case "published":
				var aux timeRFC3339
				err = unpopulate(val, &aux)
				q.Published = (*time.Time)(&aux)
				delete(rawMsg, key)
		case "title":
				err = unpopulate(val, &q.Title)
				delete(rawMsg, key)
		case "updated":
				var aux timeRFC3339
				err = unpopulate(val, &aux)
				q.Updated = (*time.Time)(&aux)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// QueueDescriptionEntryContent - The QueueDescription
type QueueDescriptionEntryContent struct {
	// Description of a Service Bus queue resource.
	QueueDescription *QueueDescription `json:"QueueDescription,omitempty"`

	// Type of content in queue response
	Type *string `json:"type,omitempty"`
}

// QueueDescriptionFeed - Response from listing Service Bus queues.
type QueueDescriptionFeed struct {
	// Queue entries.
	Entry []*QueueDescriptionEntry `json:"entry,omitempty"`

	// URL of the list queues query.
	ID *string `json:"id,omitempty"`

	// Links to paginated response.
	Link []*ResponseLink `json:"link,omitempty"`

	// The entity type for the feed.
	Title map[string]interface{} `json:"title,omitempty"`

	// Datetime of the query.
	Updated *time.Time `json:"updated,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type QueueDescriptionFeed.
func (q QueueDescriptionFeed) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "entry", q.Entry)
	populate(objectMap, "id", q.ID)
	populate(objectMap, "link", q.Link)
	populate(objectMap, "title", q.Title)
	populate(objectMap, "updated", (*timeRFC3339)(q.Updated))
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type QueueDescriptionFeed.
func (q *QueueDescriptionFeed) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "entry":
				err = unpopulate(val, &q.Entry)
				delete(rawMsg, key)
		case "id":
				err = unpopulate(val, &q.ID)
				delete(rawMsg, key)
		case "link":
				err = unpopulate(val, &q.Link)
				delete(rawMsg, key)
		case "title":
				err = unpopulate(val, &q.Title)
				delete(rawMsg, key)
		case "updated":
				var aux timeRFC3339
				err = unpopulate(val, &aux)
				q.Updated = (*time.Time)(&aux)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ResponseAuthor - The author that created this resource
type ResponseAuthor struct {
	// The Service Bus namespace
	Name *string `xml:"name"`
}

// ResponseLink - The URL for the HTTP request
type ResponseLink struct {
	// The URL of the GET request
	Href *string `xml:"href,attr"`

	// What the link href is relative to
	Rel *string `xml:"rel,attr"`
}

// RuleActionClassification provides polymorphic access to related types.
// Call the interface's GetRuleAction() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *EmptyRuleAction, *RuleAction, *SqlRuleAction
type RuleActionClassification interface {
	// GetRuleAction returns the RuleAction content of the underlying type.
	GetRuleAction() *RuleAction
}

type RuleAction struct {
	// REQUIRED
	Type *string `json:"type,omitempty"`
}

// GetRuleAction implements the RuleActionClassification interface for type RuleAction.
func (r *RuleAction) GetRuleAction() *RuleAction { return r }

// UnmarshalJSON implements the json.Unmarshaller interface for type RuleAction.
func (r *RuleAction) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return r.unmarshalInternal(rawMsg)
}

func (r RuleAction) marshalInternal(discValue string) map[string]interface{} {
	objectMap := make(map[string]interface{})
	r.Type = &discValue
	objectMap["type"] = r.Type
	return objectMap
}

func (r *RuleAction) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
				err = unpopulate(val, &r.Type)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// RuleDeleteOptions contains the optional parameters for the Rule.Delete method.
type RuleDeleteOptions struct {
}

type RuleDescription struct {
	Action RuleActionClassification `json:"action,omitempty"`

	// The exact time the rule was created.
	CreatedAt *time.Time `json:"createdAt,omitempty"`
	Filter RuleFilterClassification `json:"filter,omitempty"`
	Name *string `json:"name,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RuleDescription.
func (r RuleDescription) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "action", r.Action)
	populate(objectMap, "createdAt", (*timeRFC3339)(r.CreatedAt))
	populate(objectMap, "filter", r.Filter)
	populate(objectMap, "name", r.Name)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RuleDescription.
func (r *RuleDescription) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "action":
				r.Action, err = unmarshalRuleActionClassification(val)
				delete(rawMsg, key)
		case "createdAt":
				var aux timeRFC3339
				err = unpopulate(val, &aux)
				r.CreatedAt = (*time.Time)(&aux)
				delete(rawMsg, key)
		case "filter":
				r.Filter, err = unmarshalRuleFilterClassification(val)
				delete(rawMsg, key)
		case "name":
				err = unpopulate(val, &r.Name)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// RuleDescriptionEntry - Represents an entry in the feed when querying rules
type RuleDescriptionEntry struct {
	// The RuleDescription
	Content *RuleDescriptionEntryContent `json:"content,omitempty"`

	// The URL of the GET request
	ID *string `json:"id,omitempty"`

	// The URL for the HTTP request
	Link *ResponseLink `json:"link,omitempty"`

	// The timestamp for when this rule was published
	Published *time.Time `json:"published,omitempty"`

	// The name of the rule
	Title map[string]interface{} `json:"title,omitempty"`

	// The timestamp for when this rule was last updated
	Updated *time.Time `json:"updated,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RuleDescriptionEntry.
func (r RuleDescriptionEntry) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "content", r.Content)
	populate(objectMap, "id", r.ID)
	populate(objectMap, "link", r.Link)
	populate(objectMap, "published", (*timeRFC3339)(r.Published))
	populate(objectMap, "title", r.Title)
	populate(objectMap, "updated", (*timeRFC3339)(r.Updated))
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RuleDescriptionEntry.
func (r *RuleDescriptionEntry) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "content":
				err = unpopulate(val, &r.Content)
				delete(rawMsg, key)
		case "id":
				err = unpopulate(val, &r.ID)
				delete(rawMsg, key)
		case "link":
				err = unpopulate(val, &r.Link)
				delete(rawMsg, key)
		case "published":
				var aux timeRFC3339
				err = unpopulate(val, &aux)
				r.Published = (*time.Time)(&aux)
				delete(rawMsg, key)
		case "title":
				err = unpopulate(val, &r.Title)
				delete(rawMsg, key)
		case "updated":
				var aux timeRFC3339
				err = unpopulate(val, &aux)
				r.Updated = (*time.Time)(&aux)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// RuleDescriptionEntryContent - The RuleDescription
type RuleDescriptionEntryContent struct {
	RuleDescription *RuleDescription `json:"RuleDescription,omitempty"`

	// Type of content in rule response
	Type *string `json:"type,omitempty"`
}

// RuleDescriptionFeed - Response from listing Service Bus rules.
type RuleDescriptionFeed struct {
	// Rules entries.
	Entry []*RuleDescriptionEntry `json:"entry,omitempty"`

	// URL of the list rules query.
	ID *string `json:"id,omitempty"`

	// Links to paginated response.
	Link []*ResponseLink `json:"link,omitempty"`

	// The entity type for the feed.
	Title map[string]interface{} `json:"title,omitempty"`

	// Datetime of the query.
	Updated *time.Time `json:"updated,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type RuleDescriptionFeed.
func (r RuleDescriptionFeed) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "entry", r.Entry)
	populate(objectMap, "id", r.ID)
	populate(objectMap, "link", r.Link)
	populate(objectMap, "title", r.Title)
	populate(objectMap, "updated", (*timeRFC3339)(r.Updated))
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RuleDescriptionFeed.
func (r *RuleDescriptionFeed) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "entry":
				err = unpopulate(val, &r.Entry)
				delete(rawMsg, key)
		case "id":
				err = unpopulate(val, &r.ID)
				delete(rawMsg, key)
		case "link":
				err = unpopulate(val, &r.Link)
				delete(rawMsg, key)
		case "title":
				err = unpopulate(val, &r.Title)
				delete(rawMsg, key)
		case "updated":
				var aux timeRFC3339
				err = unpopulate(val, &aux)
				r.Updated = (*time.Time)(&aux)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// RuleFilterClassification provides polymorphic access to related types.
// Call the interface's GetRuleFilter() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *CorrelationFilter, *FalseFilter, *RuleFilter, *SqlFilter, *TrueFilter
type RuleFilterClassification interface {
	// GetRuleFilter returns the RuleFilter content of the underlying type.
	GetRuleFilter() *RuleFilter
}

type RuleFilter struct {
	// REQUIRED
	Type *string `json:"type,omitempty"`
}

// GetRuleFilter implements the RuleFilterClassification interface for type RuleFilter.
func (r *RuleFilter) GetRuleFilter() *RuleFilter { return r }

// UnmarshalJSON implements the json.Unmarshaller interface for type RuleFilter.
func (r *RuleFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return r.unmarshalInternal(rawMsg)
}

func (r RuleFilter) marshalInternal(discValue string) map[string]interface{} {
	objectMap := make(map[string]interface{})
	r.Type = &discValue
	objectMap["type"] = r.Type
	return objectMap
}

func (r *RuleFilter) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
				err = unpopulate(val, &r.Type)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// RuleGetOptions contains the optional parameters for the Rule.Get method.
type RuleGetOptions struct {
	// A query parameter that sets enrich to true or false.
	Enrich *bool
}

// RulePutOptions contains the optional parameters for the Rule.Put method.
type RulePutOptions struct {
	// Match condition for an entity to be updated. If specified and a matching entity is not found, an error will be raised. To force an unconditional update,
// set to the wildcard character (*). If not specified, an insert will be performed when no existing entity is found to update and a replace will be performed
// if an existing entity is found.
	IfMatch *string
}

// SQLFilterClassification provides polymorphic access to related types.
// Call the interface's GetSQLFilter() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *FalseFilter, *SQLFilter, *TrueFilter
type SQLFilterClassification interface {
	RuleFilterClassification
	// GetSQLFilter returns the SQLFilter content of the underlying type.
	GetSQLFilter() *SQLFilter
}

type SQLFilter struct {
	RuleFilter
	CompatibilityLevel *string `json:"compatibilityLevel,omitempty"`
	Parameters []*KeyValue `json:"parameters,omitempty"`
	RequiresPreprocessing *bool `json:"requiresPreprocessing,omitempty"`
	SQLExpression *string `json:"sqlExpression,omitempty"`
}

// GetSQLFilter implements the SQLFilterClassification interface for type SQLFilter.
func (s *SQLFilter) GetSQLFilter() *SQLFilter { return s }

// MarshalJSON implements the json.Marshaller interface for type SQLFilter.
func (s SQLFilter) MarshalJSON() ([]byte, error) {
	objectMap := s.marshalInternal("SqlFilter")
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLFilter.
func (s *SQLFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return s.unmarshalInternal(rawMsg)
}

func (s SQLFilter) marshalInternal(discValue string) map[string]interface{} {
	objectMap := s.RuleFilter.marshalInternal(discValue)
	populate(objectMap, "compatibilityLevel", s.CompatibilityLevel)
	populate(objectMap, "parameters", s.Parameters)
	populate(objectMap, "requiresPreprocessing", s.RequiresPreprocessing)
	populate(objectMap, "sqlExpression", s.SQLExpression)
	return objectMap
}

func (s *SQLFilter) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "compatibilityLevel":
				err = unpopulate(val, &s.CompatibilityLevel)
				delete(rawMsg, key)
		case "parameters":
				err = unpopulate(val, &s.Parameters)
				delete(rawMsg, key)
		case "requiresPreprocessing":
				err = unpopulate(val, &s.RequiresPreprocessing)
				delete(rawMsg, key)
		case "sqlExpression":
				err = unpopulate(val, &s.SQLExpression)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.RuleFilter.unmarshalInternal(rawMsg)
}

type SQLRuleAction struct {
	RuleAction
	CompatibilityLevel *string `json:"compatibilityLevel,omitempty"`
	Parameters []*KeyValue `json:"parameters,omitempty"`
	RequiresPreprocessing *bool `json:"requiresPreprocessing,omitempty"`
	SQLExpression *string `json:"sqlExpression,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLRuleAction.
func (s SQLRuleAction) MarshalJSON() ([]byte, error) {
	objectMap := s.RuleAction.marshalInternal("SqlRuleAction")
	populate(objectMap, "compatibilityLevel", s.CompatibilityLevel)
	populate(objectMap, "parameters", s.Parameters)
	populate(objectMap, "requiresPreprocessing", s.RequiresPreprocessing)
	populate(objectMap, "sqlExpression", s.SQLExpression)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLRuleAction.
func (s *SQLRuleAction) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "compatibilityLevel":
				err = unpopulate(val, &s.CompatibilityLevel)
				delete(rawMsg, key)
		case "parameters":
				err = unpopulate(val, &s.Parameters)
				delete(rawMsg, key)
		case "requiresPreprocessing":
				err = unpopulate(val, &s.RequiresPreprocessing)
				delete(rawMsg, key)
		case "sqlExpression":
				err = unpopulate(val, &s.SQLExpression)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return s.RuleAction.unmarshalInternal(rawMsg)
}

// ServiceBusManagementClientListEntitiesOptions contains the optional parameters for the ServiceBusManagementClient.ListEntities method.
type ServiceBusManagementClientListEntitiesOptions struct {
	Skip *int32
	Top *int32
}

// ServiceBusManagementClientListRulesOptions contains the optional parameters for the ServiceBusManagementClient.ListRules method.
type ServiceBusManagementClientListRulesOptions struct {
	Skip *int32
	Top *int32
}

// ServiceBusManagementClientListSubscriptionsOptions contains the optional parameters for the ServiceBusManagementClient.ListSubscriptions method.
type ServiceBusManagementClientListSubscriptionsOptions struct {
	Skip *int32
	Top *int32
}

// ServiceBusManagementError - The error response from Service Bus.
// Implements the error and azcore.HTTPResponse interfaces.
type ServiceBusManagementError struct {
	raw string
	// The service error code.
	Code *int32 `xml:"Code"`

	// The service error message.
	Detail *string `xml:"Detail"`
}

// Error implements the error interface for type ServiceBusManagementError.
// The contents of the error text are not contractual and subject to change.
func (e ServiceBusManagementError) Error() string {
	return e.raw
}

// SubscriptionDeleteOptions contains the optional parameters for the Subscription.Delete method.
type SubscriptionDeleteOptions struct {
}

// SubscriptionDescription - Description of a Service Bus subscription resource.
type SubscriptionDescription struct {
	// Last time a message was sent, or the last time there was a receive request to this subscription.
	AccessedAt *time.Time `json:"accessedAt,omitempty"`

	// ISO 8601 timeSpan idle interval after which the subscription is automatically deleted. The minimum duration is 5 minutes.
	AutoDeleteOnIdle *string `json:"autoDeleteOnIdle,omitempty"`

	// The exact time the subscription was created.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// A value that indicates whether this subscription has dead letter support when a message expires.
	DeadLetteringOnFilterEvaluationExceptions *bool `json:"deadLetteringOnFilterEvaluationExceptions,omitempty"`

	// A value that indicates whether this subscription has dead letter support when a message expires.
	DeadLetteringOnMessageExpiration *bool `json:"deadLetteringOnMessageExpiration,omitempty"`

	// ISO 8601 default message timespan to live value. This is the duration after which the message expires, starting from when the message is sent to Service
// Bus. This is the default value used when
// TimeToLive is not set on a message itself.
	DefaultMessageTimeToLive *string `json:"defaultMessageTimeToLive,omitempty"`

	// Value that indicates whether server-side batched operations are enabled.
	EnableBatchedOperations *bool `json:"enableBatchedOperations,omitempty"`

	// Availability status of the entity
	EntityAvailabilityStatus *EntityAvailabilityStatus `json:"entityAvailabilityStatus,omitempty"`

	// The name of the recipient entity to which all the messages sent to the subscription are forwarded to.
	ForwardDeadLetteredMessagesTo *string `json:"forwardDeadLetteredMessagesTo,omitempty"`

	// The name of the recipient entity to which all the messages sent to the subscription are forwarded to.
	ForwardTo *string `json:"forwardTo,omitempty"`

	// ISO 8601 timespan duration of a peek-lock; that is, the amount of time that the message is locked for other receivers. The maximum value for LockDuration
// is 5 minutes; the default value is 1 minute.
	LockDuration *string `json:"lockDuration,omitempty"`

	// The maximum delivery count. A message is automatically deadlettered after this number of deliveries. Default value is 10.
	MaxDeliveryCount *int32 `json:"maxDeliveryCount,omitempty"`

	// The number of messages in the subscription.
	MessageCount *int32 `json:"messageCount,omitempty"`

	// Details about the message counts in entity.
	MessageCountDetails *MessageCountDetails `json:"messageCountDetails,omitempty"`

	// A value that indicates whether the subscription supports the concept of sessions.
	RequiresSession *bool `json:"requiresSession,omitempty"`

	// Status of a Service Bus resource
	Status *EntityStatus `json:"status,omitempty"`

	// The exact time a message was updated in the subscription.
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Metadata associated with the subscription. Maximum number of characters is 1024.
	UserMetadata *string `json:"userMetadata,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SubscriptionDescription.
func (s SubscriptionDescription) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accessedAt", (*timeRFC3339)(s.AccessedAt))
	populate(objectMap, "autoDeleteOnIdle", s.AutoDeleteOnIdle)
	populate(objectMap, "createdAt", (*timeRFC3339)(s.CreatedAt))
	populate(objectMap, "deadLetteringOnFilterEvaluationExceptions", s.DeadLetteringOnFilterEvaluationExceptions)
	populate(objectMap, "deadLetteringOnMessageExpiration", s.DeadLetteringOnMessageExpiration)
	populate(objectMap, "defaultMessageTimeToLive", s.DefaultMessageTimeToLive)
	populate(objectMap, "enableBatchedOperations", s.EnableBatchedOperations)
	populate(objectMap, "entityAvailabilityStatus", s.EntityAvailabilityStatus)
	populate(objectMap, "forwardDeadLetteredMessagesTo", s.ForwardDeadLetteredMessagesTo)
	populate(objectMap, "forwardTo", s.ForwardTo)
	populate(objectMap, "lockDuration", s.LockDuration)
	populate(objectMap, "maxDeliveryCount", s.MaxDeliveryCount)
	populate(objectMap, "messageCount", s.MessageCount)
	populate(objectMap, "messageCountDetails", s.MessageCountDetails)
	populate(objectMap, "requiresSession", s.RequiresSession)
	populate(objectMap, "status", s.Status)
	populate(objectMap, "updatedAt", (*timeRFC3339)(s.UpdatedAt))
	populate(objectMap, "userMetadata", s.UserMetadata)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SubscriptionDescription.
func (s *SubscriptionDescription) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessedAt":
				var aux timeRFC3339
				err = unpopulate(val, &aux)
				s.AccessedAt = (*time.Time)(&aux)
				delete(rawMsg, key)
		case "autoDeleteOnIdle":
				err = unpopulate(val, &s.AutoDeleteOnIdle)
				delete(rawMsg, key)
		case "createdAt":
				var aux timeRFC3339
				err = unpopulate(val, &aux)
				s.CreatedAt = (*time.Time)(&aux)
				delete(rawMsg, key)
		case "deadLetteringOnFilterEvaluationExceptions":
				err = unpopulate(val, &s.DeadLetteringOnFilterEvaluationExceptions)
				delete(rawMsg, key)
		case "deadLetteringOnMessageExpiration":
				err = unpopulate(val, &s.DeadLetteringOnMessageExpiration)
				delete(rawMsg, key)
		case "defaultMessageTimeToLive":
				err = unpopulate(val, &s.DefaultMessageTimeToLive)
				delete(rawMsg, key)
		case "enableBatchedOperations":
				err = unpopulate(val, &s.EnableBatchedOperations)
				delete(rawMsg, key)
		case "entityAvailabilityStatus":
				err = unpopulate(val, &s.EntityAvailabilityStatus)
				delete(rawMsg, key)
		case "forwardDeadLetteredMessagesTo":
				err = unpopulate(val, &s.ForwardDeadLetteredMessagesTo)
				delete(rawMsg, key)
		case "forwardTo":
				err = unpopulate(val, &s.ForwardTo)
				delete(rawMsg, key)
		case "lockDuration":
				err = unpopulate(val, &s.LockDuration)
				delete(rawMsg, key)
		case "maxDeliveryCount":
				err = unpopulate(val, &s.MaxDeliveryCount)
				delete(rawMsg, key)
		case "messageCount":
				err = unpopulate(val, &s.MessageCount)
				delete(rawMsg, key)
		case "messageCountDetails":
				err = unpopulate(val, &s.MessageCountDetails)
				delete(rawMsg, key)
		case "requiresSession":
				err = unpopulate(val, &s.RequiresSession)
				delete(rawMsg, key)
		case "status":
				err = unpopulate(val, &s.Status)
				delete(rawMsg, key)
		case "updatedAt":
				var aux timeRFC3339
				err = unpopulate(val, &aux)
				s.UpdatedAt = (*time.Time)(&aux)
				delete(rawMsg, key)
		case "userMetadata":
				err = unpopulate(val, &s.UserMetadata)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SubscriptionDescriptionEntry - Represents an entry in the feed when querying subscriptions.
type SubscriptionDescriptionEntry struct {
	// The SubscriptionDescription.
	Content *SubscriptionDescriptionEntryContent `json:"content,omitempty"`

	// The URL of the GET request
	ID *string `json:"id,omitempty"`

	// The URL for the HTTP request
	Link *ResponseLink `json:"link,omitempty"`

	// The timestamp for when this subscription was published
	Published *time.Time `json:"published,omitempty"`

	// The name of the subscription
	Title map[string]interface{} `json:"title,omitempty"`

	// The timestamp for when this subscription was last updated
	Updated *time.Time `json:"updated,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SubscriptionDescriptionEntry.
func (s SubscriptionDescriptionEntry) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "content", s.Content)
	populate(objectMap, "id", s.ID)
	populate(objectMap, "link", s.Link)
	populate(objectMap, "published", (*timeRFC3339)(s.Published))
	populate(objectMap, "title", s.Title)
	populate(objectMap, "updated", (*timeRFC3339)(s.Updated))
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SubscriptionDescriptionEntry.
func (s *SubscriptionDescriptionEntry) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "content":
				err = unpopulate(val, &s.Content)
				delete(rawMsg, key)
		case "id":
				err = unpopulate(val, &s.ID)
				delete(rawMsg, key)
		case "link":
				err = unpopulate(val, &s.Link)
				delete(rawMsg, key)
		case "published":
				var aux timeRFC3339
				err = unpopulate(val, &aux)
				s.Published = (*time.Time)(&aux)
				delete(rawMsg, key)
		case "title":
				err = unpopulate(val, &s.Title)
				delete(rawMsg, key)
		case "updated":
				var aux timeRFC3339
				err = unpopulate(val, &aux)
				s.Updated = (*time.Time)(&aux)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SubscriptionDescriptionEntryContent - The SubscriptionDescription.
type SubscriptionDescriptionEntryContent struct {
	// Description of a Service Bus subscription resource.
	SubscriptionDescription *SubscriptionDescription `json:"SubscriptionDescription,omitempty"`

	// Type of content in subscription response
	Type *string `json:"type,omitempty"`
}

// SubscriptionDescriptionFeed - Response from listing Service Bus subscriptions.
type SubscriptionDescriptionFeed struct {
	// Subscription entries.
	Entry []*SubscriptionDescriptionEntry `json:"entry,omitempty"`

	// URL of the list subscriptions query.
	ID *string `json:"id,omitempty"`

	// Links to paginated response.
	Link []*ResponseLink `json:"link,omitempty"`

	// The entity type for the feed.
	Title map[string]interface{} `json:"title,omitempty"`

	// Datetime of the query.
	Updated *time.Time `json:"updated,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SubscriptionDescriptionFeed.
func (s SubscriptionDescriptionFeed) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "entry", s.Entry)
	populate(objectMap, "id", s.ID)
	populate(objectMap, "link", s.Link)
	populate(objectMap, "title", s.Title)
	populate(objectMap, "updated", (*timeRFC3339)(s.Updated))
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SubscriptionDescriptionFeed.
func (s *SubscriptionDescriptionFeed) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "entry":
				err = unpopulate(val, &s.Entry)
				delete(rawMsg, key)
		case "id":
				err = unpopulate(val, &s.ID)
				delete(rawMsg, key)
		case "link":
				err = unpopulate(val, &s.Link)
				delete(rawMsg, key)
		case "title":
				err = unpopulate(val, &s.Title)
				delete(rawMsg, key)
		case "updated":
				var aux timeRFC3339
				err = unpopulate(val, &aux)
				s.Updated = (*time.Time)(&aux)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// SubscriptionGetOptions contains the optional parameters for the Subscription.Get method.
type SubscriptionGetOptions struct {
	// A query parameter that sets enrich to true or false.
	Enrich *bool
}

// SubscriptionPutOptions contains the optional parameters for the Subscription.Put method.
type SubscriptionPutOptions struct {
	// Match condition for an entity to be updated. If specified and a matching entity is not found, an error will be raised. To force an unconditional update,
// set to the wildcard character (*). If not specified, an insert will be performed when no existing entity is found to update and a replace will be performed
// if an existing entity is found.
	IfMatch *string
}

// TopicDescription - Description of a Service Bus topic resource.
type TopicDescription struct {
	// Last time a message was sent, or the last time there was a receive request to this topic.
	AccessedAt *time.Time `json:"accessedAt,omitempty"`

	// Authorization rules for resource.
	AuthorizationRules []*AuthorizationRule `json:"authorizationRules,omitempty"`

	// ISO 8601 timeSpan idle interval after which the topic is automatically deleted. The minimum duration is 5 minutes.
	AutoDeleteOnIdle *string `json:"autoDeleteOnIdle,omitempty"`

	// The exact time the topic was created.
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// ISO 8601 default message timespan to live value. This is the duration after which the message expires, starting from when the message is sent to Service
// Bus. This is the default value used when
// TimeToLive is not set on a message itself.
	DefaultMessageTimeToLive *string `json:"defaultMessageTimeToLive,omitempty"`

	// ISO 8601 timeSpan structure that defines the duration of the duplicate detection history. The default value is 10 minutes.
	DuplicateDetectionHistoryTimeWindow *string `json:"duplicateDetectionHistoryTimeWindow,omitempty"`

	// Value that indicates whether server-side batched operations are enabled.
	EnableBatchedOperations *bool `json:"enableBatchedOperations,omitempty"`

	// A value that indicates whether Express Entities are enabled. An express topic holds a message in memory temporarily before writing it to persistent storage.
	EnableExpress *bool `json:"enableExpress,omitempty"`

	// A value that indicates whether the topic is to be partitioned across multiple message brokers.
	EnablePartitioning *bool `json:"enablePartitioning,omitempty"`

	// A value that indicates whether the topic's subscription is to be partitioned.
	EnableSubscriptionPartitioning *bool `json:"enableSubscriptionPartitioning,omitempty"`

	// Availability status of the entity
	EntityAvailabilityStatus *EntityAvailabilityStatus `json:"entityAvailabilityStatus,omitempty"`

	// Filter messages before publishing.
	FilteringMessagesBeforePublishing *bool `json:"filteringMessagesBeforePublishing,omitempty"`

	// A value indicating if the resource can be accessed without authorization.
	IsAnonymousAccessible *bool `json:"isAnonymousAccessible,omitempty"`

	// The maximum size of the topic in megabytes, which is the size of memory allocated for the topic.
	MaxSizeInMegabytes *int64 `json:"maxSizeInMegabytes,omitempty"`

	// Details about the message counts in entity.
	MessageCountDetails *MessageCountDetails `json:"messageCountDetails,omitempty"`

	// A value indicating if this topic requires duplicate detection.
	RequiresDuplicateDetection *bool `json:"requiresDuplicateDetection,omitempty"`

	// The size of the topic, in bytes.
	SizeInBytes *int32 `json:"sizeInBytes,omitempty"`

	// Status of a Service Bus resource
	Status *EntityStatus `json:"status,omitempty"`

	// The number of subscriptions in the topic.
	SubscriptionCount *int32 `json:"subscriptionCount,omitempty"`

	// A value that indicates whether the topic supports ordering.
	SupportOrdering *bool `json:"supportOrdering,omitempty"`

	// The exact time a message was updated in the topic.
	UpdatedAt *time.Time `json:"updatedAt,omitempty"`

	// Metadata associated with the topic.
	UserMetadata *string `json:"userMetadata,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TopicDescription.
func (t TopicDescription) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accessedAt", (*timeRFC3339)(t.AccessedAt))
	populate(objectMap, "authorizationRules", t.AuthorizationRules)
	populate(objectMap, "autoDeleteOnIdle", t.AutoDeleteOnIdle)
	populate(objectMap, "createdAt", (*timeRFC3339)(t.CreatedAt))
	populate(objectMap, "defaultMessageTimeToLive", t.DefaultMessageTimeToLive)
	populate(objectMap, "duplicateDetectionHistoryTimeWindow", t.DuplicateDetectionHistoryTimeWindow)
	populate(objectMap, "enableBatchedOperations", t.EnableBatchedOperations)
	populate(objectMap, "enableExpress", t.EnableExpress)
	populate(objectMap, "enablePartitioning", t.EnablePartitioning)
	populate(objectMap, "enableSubscriptionPartitioning", t.EnableSubscriptionPartitioning)
	populate(objectMap, "entityAvailabilityStatus", t.EntityAvailabilityStatus)
	populate(objectMap, "filteringMessagesBeforePublishing", t.FilteringMessagesBeforePublishing)
	populate(objectMap, "isAnonymousAccessible", t.IsAnonymousAccessible)
	populate(objectMap, "maxSizeInMegabytes", t.MaxSizeInMegabytes)
	populate(objectMap, "messageCountDetails", t.MessageCountDetails)
	populate(objectMap, "requiresDuplicateDetection", t.RequiresDuplicateDetection)
	populate(objectMap, "sizeInBytes", t.SizeInBytes)
	populate(objectMap, "status", t.Status)
	populate(objectMap, "subscriptionCount", t.SubscriptionCount)
	populate(objectMap, "supportOrdering", t.SupportOrdering)
	populate(objectMap, "updatedAt", (*timeRFC3339)(t.UpdatedAt))
	populate(objectMap, "userMetadata", t.UserMetadata)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TopicDescription.
func (t *TopicDescription) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accessedAt":
				var aux timeRFC3339
				err = unpopulate(val, &aux)
				t.AccessedAt = (*time.Time)(&aux)
				delete(rawMsg, key)
		case "authorizationRules":
				err = unpopulate(val, &t.AuthorizationRules)
				delete(rawMsg, key)
		case "autoDeleteOnIdle":
				err = unpopulate(val, &t.AutoDeleteOnIdle)
				delete(rawMsg, key)
		case "createdAt":
				var aux timeRFC3339
				err = unpopulate(val, &aux)
				t.CreatedAt = (*time.Time)(&aux)
				delete(rawMsg, key)
		case "defaultMessageTimeToLive":
				err = unpopulate(val, &t.DefaultMessageTimeToLive)
				delete(rawMsg, key)
		case "duplicateDetectionHistoryTimeWindow":
				err = unpopulate(val, &t.DuplicateDetectionHistoryTimeWindow)
				delete(rawMsg, key)
		case "enableBatchedOperations":
				err = unpopulate(val, &t.EnableBatchedOperations)
				delete(rawMsg, key)
		case "enableExpress":
				err = unpopulate(val, &t.EnableExpress)
				delete(rawMsg, key)
		case "enablePartitioning":
				err = unpopulate(val, &t.EnablePartitioning)
				delete(rawMsg, key)
		case "enableSubscriptionPartitioning":
				err = unpopulate(val, &t.EnableSubscriptionPartitioning)
				delete(rawMsg, key)
		case "entityAvailabilityStatus":
				err = unpopulate(val, &t.EntityAvailabilityStatus)
				delete(rawMsg, key)
		case "filteringMessagesBeforePublishing":
				err = unpopulate(val, &t.FilteringMessagesBeforePublishing)
				delete(rawMsg, key)
		case "isAnonymousAccessible":
				err = unpopulate(val, &t.IsAnonymousAccessible)
				delete(rawMsg, key)
		case "maxSizeInMegabytes":
				err = unpopulate(val, &t.MaxSizeInMegabytes)
				delete(rawMsg, key)
		case "messageCountDetails":
				err = unpopulate(val, &t.MessageCountDetails)
				delete(rawMsg, key)
		case "requiresDuplicateDetection":
				err = unpopulate(val, &t.RequiresDuplicateDetection)
				delete(rawMsg, key)
		case "sizeInBytes":
				err = unpopulate(val, &t.SizeInBytes)
				delete(rawMsg, key)
		case "status":
				err = unpopulate(val, &t.Status)
				delete(rawMsg, key)
		case "subscriptionCount":
				err = unpopulate(val, &t.SubscriptionCount)
				delete(rawMsg, key)
		case "supportOrdering":
				err = unpopulate(val, &t.SupportOrdering)
				delete(rawMsg, key)
		case "updatedAt":
				var aux timeRFC3339
				err = unpopulate(val, &aux)
				t.UpdatedAt = (*time.Time)(&aux)
				delete(rawMsg, key)
		case "userMetadata":
				err = unpopulate(val, &t.UserMetadata)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// TopicDescriptionEntry - Represents an entry in the feed when querying topics
type TopicDescriptionEntry struct {
	// The author that created this resource
	Author *ResponseAuthor `json:"author,omitempty"`

	// Base URL for the query.
	Base *string `json:"base,omitempty"`

	// The TopicDescription
	Content *TopicDescriptionEntryContent `json:"content,omitempty"`

	// The URL of the GET request
	ID *string `json:"id,omitempty"`

	// The URL for the HTTP request
	Link *ResponseLink `json:"link,omitempty"`

	// The timestamp for when this topic was published
	Published *time.Time `json:"published,omitempty"`

	// The name of the topic
	Title map[string]interface{} `json:"title,omitempty"`

	// The timestamp for when this topic was last updated
	Updated *time.Time `json:"updated,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TopicDescriptionEntry.
func (t TopicDescriptionEntry) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "author", t.Author)
	populate(objectMap, "base", t.Base)
	populate(objectMap, "content", t.Content)
	populate(objectMap, "id", t.ID)
	populate(objectMap, "link", t.Link)
	populate(objectMap, "published", (*timeRFC3339)(t.Published))
	populate(objectMap, "title", t.Title)
	populate(objectMap, "updated", (*timeRFC3339)(t.Updated))
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TopicDescriptionEntry.
func (t *TopicDescriptionEntry) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "author":
				err = unpopulate(val, &t.Author)
				delete(rawMsg, key)
		case "base":
				err = unpopulate(val, &t.Base)
				delete(rawMsg, key)
		case "content":
				err = unpopulate(val, &t.Content)
				delete(rawMsg, key)
		case "id":
				err = unpopulate(val, &t.ID)
				delete(rawMsg, key)
		case "link":
				err = unpopulate(val, &t.Link)
				delete(rawMsg, key)
		case "published":
				var aux timeRFC3339
				err = unpopulate(val, &aux)
				t.Published = (*time.Time)(&aux)
				delete(rawMsg, key)
		case "title":
				err = unpopulate(val, &t.Title)
				delete(rawMsg, key)
		case "updated":
				var aux timeRFC3339
				err = unpopulate(val, &aux)
				t.Updated = (*time.Time)(&aux)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// TopicDescriptionEntryContent - The TopicDescription
type TopicDescriptionEntryContent struct {
	// Description of a Service Bus topic resource.
	TopicDescription *TopicDescription `json:"TopicDescription,omitempty"`

	// Type of content in topic response
	Type *string `json:"type,omitempty"`
}

// TopicDescriptionFeed - Response from listing Service Bus topics.
type TopicDescriptionFeed struct {
	// Topic entries.
	Entry []*TopicDescriptionEntry `json:"entry,omitempty"`

	// URL of the list topics query.
	ID *string `json:"id,omitempty"`

	// Links to paginated response.
	Link []*ResponseLink `json:"link,omitempty"`

	// The entity type for the feed.
	Title map[string]interface{} `json:"title,omitempty"`

	// Datetime of the query.
	Updated *time.Time `json:"updated,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TopicDescriptionFeed.
func (t TopicDescriptionFeed) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "entry", t.Entry)
	populate(objectMap, "id", t.ID)
	populate(objectMap, "link", t.Link)
	populate(objectMap, "title", t.Title)
	populate(objectMap, "updated", (*timeRFC3339)(t.Updated))
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TopicDescriptionFeed.
func (t *TopicDescriptionFeed) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "entry":
				err = unpopulate(val, &t.Entry)
				delete(rawMsg, key)
		case "id":
				err = unpopulate(val, &t.ID)
				delete(rawMsg, key)
		case "link":
				err = unpopulate(val, &t.Link)
				delete(rawMsg, key)
		case "title":
				err = unpopulate(val, &t.Title)
				delete(rawMsg, key)
		case "updated":
				var aux timeRFC3339
				err = unpopulate(val, &aux)
				t.Updated = (*time.Time)(&aux)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type TrueFilter struct {
	SQLFilter
}

// MarshalJSON implements the json.Marshaller interface for type TrueFilter.
func (t TrueFilter) MarshalJSON() ([]byte, error) {
	objectMap := t.SQLFilter.marshalInternal("TrueFilter")
	return json.Marshal(objectMap)
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, v interface{}) error {
	if data == nil {
		return nil
	}
	return json.Unmarshal(data, v)
}

